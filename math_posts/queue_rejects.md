Микро #incident был: подселял коллега очередную модель в очередной сервис, для аб. Ну подселяет и подселяет - порадуемся что сам справляется, тестики, проверочки подсказывают что сделать, действие в целом шаблонное. Но вот чего-то начинают подспамливать алёртики, мол не отвечает немножко (выглядит как единичные всплески неответов).

Вечером подумал - ну кажись опять какие-то настойки поехали - стандартная тема "фон неответов если выкатывается сервис", надо проверить настройке хеджей.
А на следующий день - оно продолжает фонить и подспамливать. Ну ладно - придётся посмотреть что там.

Оказалось что "советчик по настройкам сервиса" в пр подсказал:
 "вот тут настроечка, она равна 5. А чего-это? По моим формулами лучше 4".

 Что-то человек у себя внутри подумал-подумал и вкоммитил туда вообще два. Настройка это - ограничитель infly на поде. И вот: теперь бывало что запрос не находил свободного пода (обходя все 5 подов локации). Ну что скажешь - 1) надо лучше смотреть что выкатываешь, 2) а iac в себе таит возможность приезда немного неожиданных изменений.

К чему я подвожу то? #математика , как известно, программистам не нужна, но коль её завалялось без дела под стулом - можно побаловаться.

Дано: ~130 рпс входящего потока. Время 1 запроса от 7мс до 60мс (среднее - 22мс). Есть 5 подов с лимитом в "2 инфлай". Сколько будет ошибок шедулинга?

Сразу скажу имперический ответ - их было 0.8-0.1 рпс. То есть вероятность должна оказаться примерно 0.0007 (в 7 раз хуже 4х девяток).

Что является условием для ошибки шедулинга? Наличие 10 запросов infly (и приход 11-ого). В среднем, на наших вводных, у нас должно быть 130 * 0.022 = 2.86 infly.

Ну что, берём пуассоновское распределение с `\lambda = 2.86`. Считаем `sum([math.exp(-2.86) * (2.86 ** t) / math.factorial(t) for t in range(10, 100)]) = 0.00077..`. Неплохо попали (правда, если условие ставить 11 - уже в 3 раза меньше вероятность).